<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Planning V16 — Final (corrigé)</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
/* =========================
   VARIABLES DE POSITION (modifier ici en px)
   - change les valeurs en px pour déplacer les éléments
   - tu peux aussi appeler setLayout(...) depuis la console
   ========================= */
:root{
  /* canvas / grid sizes */
  --canvas-w:1536px;
  --canvas-h:1024px;
  --grid-width:1280px;
  --time-col-w:160px;
  --slot-h:160px;
  --slot-gap:12px;
  --border-w:3px;

  /* typographie */
  --font-day:28px;
  --font-time:36px;
  --font-activity:28px;
  --font-tag:24px;
  --rules-font:20px;

  /* --- nouvelle variable : taille du label "Règles :" (modifiable) --- */
  --rules-label-font-size: 22px;

  /* couleurs */
  --default-tag-color:#ffffff;
  --roulette-default:#ffd400;
  --special-default:#ff3b3b;

  /* POSITIONS (modifiable en px) */
  --topbar-left: 540px;    /* left du topbar (px) */
  --topbar-top: 8px;       /* top du topbar (px) */
  --grid-left: 45px;       /* left du grid-wrap (px) */
  --grid-top: 200px;       /* top du grid-wrap (px) */
  --rules-left: 128px;     /* left de la zone rules (px) */
  --rules-top: 640px;      /* top de la zone rules (px) */

  /* offsets pour éléments individuels (translate) */
  --displayStart-offset-x: 0px;
  --displayStart-offset-y: 0px;
  --displayEnd-offset-x: 0px;
  --displayEnd-offset-y: 0px;
  --export-offset-x: 0px;
  --export-offset-y: 0px;
  --reset-offset-x: 0px;
  --reset-offset-y: 0px;
}

/* base */
*{box-sizing:border-box}
html,body{
  height:100%;margin:0;
  background:#000;
  font-family:Inter,system-ui,Arial;
  color:#fff;
  display:flex;align-items:center;justify-content:center;
  padding:12px;
}
.canvas-wrapper {
  position: relative;
  width: var(--canvas-w);
  height: var(--canvas-h);
  transform-origin: top left;
}
.canvas{
  width:var(--canvas-w);height:var(--canvas-h);
  position:relative;
  background-image:url('https://i.imgur.com/ceXEsYW.png');
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  background-color:#000;
  border-radius:0;
  overflow:hidden;
  box-shadow:0 20px 60px rgba(0,0,0,0.6);
}

/* topbar : positionnée via variables */
.topbar{
  z-index: 9999;
  pointer-events: auto;
  position: absolute;
  left: var(--topbar-left);
  top: var(--topbar-top);
  width: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px 0;
}
.topbar-inner{
  width: var(--grid-width);
  display: flex;
  align-items: center;
  gap: 18px;
  font-family: Cinzel, serif;
  box-sizing: border-box;
}
.date-block{
  display: flex;
  flex-direction: column;
  gap: 4px;
  position: relative;
}
.date-block .label{ font-size: 12px; opacity: 0.9; }
.date-block .value{
  font-size: var(--font-day);
  font-weight: 700;
}

/* action buttons */
.btn-primary, .btn-ghost{
  padding: 8px 12px;
  border-radius: 0;
  border: none;
  cursor: pointer;
  font-weight: 800;
}
.btn-primary{ background: #1f6feb; color: #fff; transform: translate(var(--export-offset-x), var(--export-offset-y)); }
.btn-ghost{ background: transparent; color: #fff; border: 1px solid rgba(255,255,255,0.4); transform: translate(var(--reset-offset-x), var(--reset-offset-y)); }

/* input date invisible mais positionné sous le bouton pour garantir l'ouverture du picker */
.date-input{
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  border: none;
  background: transparent;
  pointer-events: auto;
  -webkit-appearance: none;
  appearance: none;
}
.date-btn{
  position: relative;
  z-index: 2;
  background: transparent;
  border: none;
  color: inherit;
  font-family: "Cinzel", serif;
  font-weight: 700;
  font-size: var(--font-day);
  line-height: 1;
  cursor: pointer;
  padding: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* translate offsets (contrôlables via variables) */
#displayStart { transform: translate(var(--displayStart-offset-x), var(--displayStart-offset-y)); }
#displayEnd   { transform: translate(var(--displayEnd-offset-x), var(--displayEnd-offset-y)); }

.date-btn:focus{ outline: 2px solid rgba(255,255,255,0.12); }

/* grid : position via variables */
.grid-wrap{
  position: absolute;
  left: var(--grid-left);
  top: var(--grid-top);
  width: var(--grid-width);
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.grid-header{
  display: grid;
  grid-template-columns: var(--time-col-w) repeat(6, 1fr);
  gap: 12px;
  align-items: center;
}
.grid-header .time-col{
  padding-left: 8px;
  font-family: Cinzel, serif;
  font-weight: 800;
  font-size: var(--font-time);
}
.grid-header .day{
  padding: 10px;
  border-radius: 0;
  text-align: center;
  background: rgba(0,0,0,0.55);
  font-family: Cinzel, serif;
  font-weight: 800;
  font-size: var(--font-day);
}
.grid{
  display: grid;
  grid-template-columns: var(--time-col-w) repeat(6, 1fr);
  grid-auto-rows: var(--slot-h);
  gap: var(--slot-gap);
}
.time-cell{
  display: flex;
  align-items: center;
  padding-left: 80px;
  font-family: Cinzel, serif;
  font-weight: 900;
  font-size: var(--font-time);
}
.slot{
  position: relative;
  background: rgba(0,0,0,0.55);
  border: var(--border-w) solid rgba(255,255,255,0.06);
  border-radius: 0;
  padding: 12px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: stretch;
  overflow: hidden;
  cursor: pointer;
}
.slot.empty{
  display: flex;
  align-items: center;
  justify-content: center;
  color: #cfcfcf;
  font-weight: 800;
}
.slot .content{
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;
  align-items: center;
}
.activity-name{
  font-family:Cinzel,serif;font-weight:900;font-size:var(--font-activity);
  text-align:center;word-break:break-word;color:#fff;
}
.tag {
  position: absolute;
  bottom: 12px;        /* distance depuis le bas de la case */
  left: 50%;
  transform: translateX(-50%);
  font-family: Cinzel, serif;
  font-weight: 900;
  font-size: var(--font-tag);
  white-space: nowrap;
  color: var(--default-tag-color);
  background: transparent;
  pointer-events: none;
}

/* gear */
.gear{
  position:absolute;right:10px;top:10px;
  width:30px;height:30px;border-radius:0;
  display:flex;align-items:center;justify-content:center;
  background:rgba(0,0,0,0.6);
  opacity:0;transition:opacity .12s;
  cursor:pointer;font-size:16px;
}
.slot:hover .gear{opacity:1}

/* rules : position via variables */
.rules{
  position:absolute;
  left: var(--rules-left);
  top: var(--rules-top);
  width:var(--grid-width);
  padding:12px;border-radius:0;
  background:rgba(0,0,0,0.7);
  font-family:Cinzel,serif;font-size:var(--rules-font);
  display:none;flex-direction:column;gap:8px;
}
/* cible uniquement le label "Règles :" dans la zone .rules — taille contrôlable via la variable --rules-label-font-size */
.rules > .small {
  font-size: var(--rules-label-font-size);
  font-weight: 800;
}
.rules .rule-line{
  padding:10px;border-radius:0;
  background:rgba(255,255,255,0.02);
}

/* modal */
.modal-back{
  position:fixed;inset:0;
  background:rgba(0,0,0,0.6);
  display:none;align-items:center;justify-content:center;
  z-index:200;
}
.modal{
  width:820px;background:#050a10;border-radius:0;
  padding:16px;color:#fff;
  box-shadow:0 12px 40px rgba(0,0,0,0.6);
  font-family:Inter,system-ui;
}
.modal h3{font-family:Cinzel,serif;margin:0 0 8px 0}
.modal-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.section-title{font-weight:800;font-family:Cinzel,serif;margin-bottom:6px}
.select,input[type="text"],input[type="color"],textarea{
  width:100%;padding:10px;border-radius:0;
  border:1px solid rgba(255,255,255,0.2);
  background:#050a10;color:#fff;
}
.activity-list{
  max-height:260px;overflow:auto;border-radius:0;
  padding:6px;background:#020408;
  border:1px solid rgba(255,255,255,0.15);
}
.activity-item{
  padding:8px;border-radius:0;
  display:flex;justify-content:space-between;align-items:center;
  cursor:pointer;
}
.activity-item:hover{background:rgba(255,255,255,0.06)}
.color-palette{display:flex;gap:8px;align-items:center}
.color-swatch{
  width:34px;height:34px;border-radius:0;
  border:2px solid rgba(255,255,255,0.4);
  cursor:pointer;
}
.modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:100px}

/* hide UI during capture (n'affecte pas la topbar hors du canvas) */
.canvas.capture .gear,
.canvas.capture .modal-back,
.canvas.capture .btn-primary,
.canvas.capture .btn-ghost { display:none !important; }

.small{font-size:13px;opacity:0.9}

/* responsive safety */
@media (max-width: 1100px) {
  :root { --font-day: 32px; --font-time: 28px; }
  .canvas-wrapper { transform: scale(0.9); }
}
</style>
</head>
<body>
<!-- (le reste du fichier peut suivre normalement) -->
</body>
</html>

  <!-- TOPBAR (placée en dehors du canvas pour ne pas être scalée) -->
  <div class="topbar" id="topbar" role="banner" aria-label="Barre supérieure">
    <div class="topbar-inner">
      <div class="date-block">
        <div class="label small">Début</div>
        <button class="value date-btn" id="displayStart" data-type="start" aria-haspopup="dialog">—</button>
        <input type="date" id="inputStart" class="date-input" />
      </div>
      <div class="date-block">
        <div class="label small">Fin</div>
        <button class="value date-btn" id="displayEnd" data-type="end" aria-haspopup="dialog">—</button>
        <input type="date" id="inputEnd" class="date-input" />
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <button id="exportPng" class="btn-primary">Exporter PNG</button>
        <button id="resetBtn" class="btn-ghost">Réinitialiser</button>
      </div>
    </div>
  </div>

  <!-- wrapper qui sera scalée -->
  <div class="canvas-wrapper" id="canvasWrapper">
    <div class="canvas" id="canvas">

      <!-- GRID -->
      <div class="grid-wrap" id="gridWrap">
        <div class="grid-header">
          <div class="time-col"></div>
          <div class="day">Lundi</div>
          <div class="day">Mardi</div>
          <div class="day">Mercredi</div>
          <div class="day">Jeudi</div>
          <div class="day">Vendredi</div>
          <div class="day">Samedi</div>
        </div>

        <div class="grid" id="grid">
          <!-- 15H -->
          <div class="time-cell">15H</div>
          <div class="slot empty" data-day="1" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="2" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="3" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="4" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="5" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="6" data-hour="15"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>

          <!-- 21H -->
          <div class="time-cell">21H</div>
          <div class="slot empty" data-day="1" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="2" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="3" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="4" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="5" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
          <div class="slot empty" data-day="6" data-hour="21"><div class="gear">⚙</div><div class="content"><div class="activity-name">Vide</div></div></div>
        </div>
      </div>

      <!-- RULES -->
      <div class="rules" id="rulesArea">
        <div class="small">Règles :</div>
        <div id="rulesContent"></div>
      </div>

    </div>
  </div>

<!-- MODAL -->
<div class="modal-back" id="modalBack">
  <div class="modal" role="dialog" aria-modal="true">
    <h3>Éditer la case</h3>
    <div class="modal-grid">
      <!-- gauche -->
      <div>
        <div class="section-title">Activité principale</div>
        <div class="small">Catégorie</div>
        <select id="categorySelect" class="select">
          <option value="raid">Raid</option>
          <option value="donjon">Donjon</option>
          <option value="custom">Personnalisée</option>
          <option value="libre">Activité libre</option>
        </select>

        <div style="height:8px"></div>
        <div class="small">Liste / Nom</div>
        <div id="activityList" class="activity-list"></div>

        <div style="height:8px"></div>
        <div class="small">Couleur du nom</div>
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
          <div class="color-palette" id="namePalette"></div>
          <input type="color" id="nameColorPicker" value="#ffffff" />
        </div>

        <!-- slider pour taille du texte activité principale -->
        <div style="height:8px"></div>
        <div class="small">Taille du texte (activité principale)</div>
        <div class="slider-row">
          <input type="range" id="activityFontRange" min="12" max="72" step="1" />
          <div class="slider-value" id="activityFontValue">28px</div>
        </div>

      </div>

      <!-- droite -->
      <div>
        <div class="section-title">Activité spéciale</div>
        <div class="small">Type</div>
        <select id="specialSelect" class="select">
          <option value="none">Aucune</option>
          <option value="roulette">Roulette</option>
          <option value="special">Soirée spéciale</option>
          <option value="custom">Personnalisée</option>
        </select>

        <div style="height:8px"></div>
        <div class="small">Tag / Nom spécial</div>
        <input type="text" id="specialName" placeholder="Nom du tag (si personnalisé)" style="display:none" />

        <div style="height:8px"></div>
        <div class="small">Règles (modifiable)</div>
        <textarea id="specialRules" rows="5" placeholder="Texte des règles..."></textarea>

        <div style="height:8px"></div>
        <div class="small">Couleur du tag & cadre</div>
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
          <div class="color-palette" id="tagPalette"></div>
          <input type="color" id="tagColorPicker" value="#ffd400" />
        </div>
        <div style="height:6px"></div>
        <input type="text" id="tagHex" placeholder="#rrggbb" />

        <!-- slider pour taille du tag (activité spéciale) -->
        <div style="height:8px"></div>
        <div class="small">Taille du texte (tag spécial)</div>
        <div class="slider-row">
          <input type="range" id="tagFontRange" min="10" max="48" step="1" />
          <div class="slider-value" id="tagFontValue">20px</div>
        </div>

      </div>
    </div>

    <div class="modal-actions">
      <button class="btn-ghost" id="cancelBtn">Annuler</button>
      <button class="btn-primary" id="saveBtn">Enregistrer</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
/* layout (positions en px) — modifie ici si tu préfères */
const layout = {
  topbar: { left: 540, top: 8 },
  grid:   { left: 45, top: 200 },
  rules:  { left: 128, top: 640 },
  offsets: {
    displayStart: { x: 0, y: 0 },
    displayEnd:   { x: 0, y: 0 },
    export:       { x: 0, y: 0 },
    reset:        { x: 0, y: 0 }
  }
};

/* couleurs RAID / DONJON */
const RAID_DATA = [
  {name:"Désert Perpétuel", color:"#7B1FA2"},
  {name:"Serment du Disciple", color:"#2E003E"},
  {name:"Origine des Cauchemars", color:"#B00020"},
  {name:"Jardin du Salut", color:"#2ECC71"},
  {name:"Dernier Vœu", color:"#8E44AD"},
  {name:"Crypte de la Pierre", color:"#5DADE2"},
  {name:"Chute de Cropta", color:"#1ABC9C"},
  {name:"Chute du Roi", color:"#d378b2"},
  {name:"Caveau de Verre", color:"#1F8EFA"}
].sort((a,b)=> a.name.localeCompare(b.name,'fr'));

const DONJON_DATA = [
  {name:"Équilibre", color:"#BDC3C7"},
  {name:"Ruine de la Guerrière", color:"#922B21"},
  {name:"Fantôme des Profondeurs", color:"#154360"},
  {name:"Flèche de la Vigie", color:"#F1C40F"},
  {name:"Trône Brisé", color:"#6C3483"},
  {name:"Hôte Vesper", color:"#2E86C1"},
  {name:"Dualité", color:"#C0392B"},
  {name:"Fosse de l’Hérésie", color:"#145A32"},
  {name:"Étreinte de l’Avarice", color:"#F4D03F"},
  {name:"Prophétie", color:"#2C2C54"}
].sort((a,b)=> a.name.localeCompare(b.name,'fr'));

/* DOM refs */
const root = document.documentElement;
const canvas = document.getElementById('canvas');
const canvasWrapper = document.getElementById('canvasWrapper');
const topbar = document.getElementById('topbar');
const gridWrap = document.getElementById('gridWrap');
const rulesArea = document.getElementById('rulesArea');
const rulesContent = document.getElementById('rulesContent');
const displayStart = document.getElementById('displayStart');
const displayEnd = document.getElementById('displayEnd');
const inputStart = document.getElementById('inputStart');
const inputEnd = document.getElementById('inputEnd');
const modalBack = document.getElementById('modalBack');
const activityList = document.getElementById('activityList');
const categorySelect = document.getElementById('categorySelect');
const namePalette = document.getElementById('namePalette');
const nameColorPicker = document.getElementById('nameColorPicker');
const specialSelect = document.getElementById('specialSelect');
const specialName = document.getElementById('specialName');
const specialRules = document.getElementById('specialRules');
const tagPalette = document.getElementById('tagPalette');
const tagColorPicker = document.getElementById('tagColorPicker');
const tagHex = document.getElementById('tagHex');
const saveBtn = document.getElementById('saveBtn');
const cancelBtn = document.getElementById('cancelBtn');
const exportPng = document.getElementById('exportPng');
const resetBtn = document.getElementById('resetBtn');

/* sliders refs */
const activityFontRange = document.getElementById('activityFontRange');
const activityFontValue = document.getElementById('activityFontValue');
const tagFontRange = document.getElementById('tagFontRange');
const tagFontValue = document.getElementById('tagFontValue');

/* expose setLayout to change positions from console */
function applyLayoutFromObject(l){
  if (!l) return;
  if (l.topbar) {
    root.style.setProperty('--topbar-left', (l.topbar.left ?? 540) + 'px');
    root.style.setProperty('--topbar-top',  (l.topbar.top  ?? 8) + 'px');
  }
  if (l.grid) {
    root.style.setProperty('--grid-left', (l.grid.left ?? 45) + 'px');
    root.style.setProperty('--grid-top',  (l.grid.top  ?? 200) + 'px');
  }
  if (l.rules) {
    root.style.setProperty('--rules-left', (l.rules.left ?? 128) + 'px');
    root.style.setProperty('--rules-top',  (l.rules.top  ?? 640) + 'px');
  }
  if (l.offsets) {
    const o = l.offsets;
    root.style.setProperty('--displayStart-offset-x', (o.displayStart?.x ?? 0) + 'px');
    root.style.setProperty('--displayStart-offset-y', (o.displayStart?.y ?? 0) + 'px');
    root.style.setProperty('--displayEnd-offset-x',   (o.displayEnd?.x ?? 0) + 'px');
    root.style.setProperty('--displayEnd-offset-y',   (o.displayEnd?.y ?? 0) + 'px');
    root.style.setProperty('--export-offset-x',       (o.export?.x ?? 0) + 'px');
    root.style.setProperty('--export-offset-y',       (o.export?.y ?? 0) + 'px');
    root.style.setProperty('--reset-offset-x',        (o.reset?.x ?? 0) + 'px');
    root.style.setProperty('--reset-offset-y',        (o.reset?.y ?? 0) + 'px');
  }
}

/* wrapper applyLayout (keeps backward compatibility with your applyLayout) */
function applyLayout(){
  // topbar is outside canvas: position relative to body via CSS variables
  applyLayoutFromObject(layout);
  // also set inline positions for legacy code that used style.left/top directly
  if (layout.topbar) {
    topbar.style.left = layout.topbar.left + 'px';
    topbar.style.top = layout.topbar.top + 'px';
  }
  if (layout.grid) {
    gridWrap.style.left = layout.grid.left + 'px';
    gridWrap.style.top = layout.grid.top + 'px';
  }
  if (layout.rules) {
    rulesArea.style.left = layout.rules.left + 'px';
    rulesArea.style.top = layout.rules.top + 'px';
  }
}

/* util: ouvre le picker de date de façon fiable (showPicker si dispo, sinon fallback) */
function openDatePicker(input){
  if (!input) return;
  if (typeof input.showPicker === 'function') {
    try { input.showPicker(); return; } catch(e){ /* fallback */ }
  }
  input.focus();
  setTimeout(()=> {
    try { input.click(); } catch(e){ /* certains navigateurs ignorent le click programmatique */ }
  }, 10);
}

/* handlers pour les boutons d'affichage de date */
displayStart.addEventListener('click', ()=> openDatePicker(inputStart));
displayEnd.addEventListener('click',   ()=> openDatePicker(inputEnd));

/* dates init & helpers */
function formatShortDate(d){
  if(!d) return '—';
  const dt = new Date(d);
  return dt.toLocaleDateString('fr-FR',{day:'2-digit',month:'short'});
}
(function initDates(){
  const today = new Date();
  const day = today.getDay();
  const diffToMonday = (day === 0) ? -6 : (1 - day);
  const start = new Date(today); start.setDate(today.getDate() + diffToMonday);
  const end = new Date(start); end.setDate(start.getDate() + 5);

  inputStart.value = start.toISOString().slice(0,10);
  inputEnd.value = end.toISOString().slice(0,10);

  displayStart.textContent = formatShortDate(inputStart.value);
  displayEnd.textContent = formatShortDate(inputEnd.value);
})();

/* palettes */
const QUICK_COLORS = ['#ffd400','#ff3b3b','#00c853','#1e88e5','#9c27b0'];
function buildPalettes(){
  QUICK_COLORS.forEach(c=>{
    const s1 = document.createElement('div'); s1.className='color-swatch'; s1.style.background=c;
    s1.addEventListener('click', ()=> nameColorPicker.value = c);
    namePalette.appendChild(s1);
    const s2 = document.createElement('div'); s2.className='color-swatch'; s2.style.background=c;
    s2.addEventListener('click', ()=> { tagColorPicker.value = c; tagHex.value = c; });
    tagPalette.appendChild(s2);
  });
}
buildPalettes();

/* liste activités */
function renderActivityList(){
  activityList.innerHTML = '';
  const cat = categorySelect.value;
  let list = [];
  if(cat === 'raid') list = RAID_DATA;
  else if(cat === 'donjon') list = DONJON_DATA;
  
  else if(cat === 'libre') {
    activityList.innerHTML = '<div class="activity-item">Aucune sélection nécessaire</div>';
    currentSelectedActivity = { name: "Activité libre", color: "#ffffff", custom:false };
    return;
  }

  if(cat === 'custom'){
    const wrap = document.createElement('div');
    wrap.className = 'activity-item';
    wrap.textContent = 'Cliquer pour saisir une activité personnalisée';
    wrap.addEventListener('click', ()=>{
      const name = prompt("Nom de l'activité personnalisée :","Nouvelle activité") || "Activité personnalisée";
      const color = "#ffffff";
      currentSelectedActivity = { name, color, custom:true };
      highlightSelected();
    });
    activityList.appendChild(wrap);
    return;
  }

  list.forEach(a=>{
    const it = document.createElement('div'); it.className='activity-item';
    it.innerHTML = `<div>${a.name}</div><div style="width:18px;height:18px;background:${a.color};"></div>`;
    it.addEventListener('click', ()=>{
      currentSelectedActivity = { name:a.name, color:a.color, custom:false };
      nameColorPicker.value = a.color;
      highlightSelected();
    });
    activityList.appendChild(it);
  });
}
function highlightSelected(){
  Array.from(activityList.children).forEach(ch=> ch.style.background='transparent');
  if(!currentSelectedActivity) return;
  const items = Array.from(activityList.children);
  const idx = items.findIndex(it => it.textContent.trim().startsWith(currentSelectedActivity.name));
  if(idx>=0) items[idx].style.background = 'rgba(255,255,255,0.1)';
}

/* ouvrir modal */
let state = {};
let currentKey = null;
let currentSelectedActivity = null;

/* backups pour restaurer preview si annulation */
const previewBackup = {};

/* defaults for font sizes (from CSS variables) */
function getDefaultActivityFont() {
  const v = getComputedStyle(document.documentElement).getPropertyValue('--font-activity').trim();
  return parseInt(v) || 28;
}
function getDefaultTagFont() {
  const v = getComputedStyle(document.documentElement).getPropertyValue('--font-tag').trim();
  return parseInt(v) || 20;
}

function openModalForKey(key){
  currentKey = key;
  const s = state[key];

  categorySelect.value = 'raid';
  specialSelect.value = 'none';
  specialName.style.display = 'none';
  specialName.value = '';
  specialRules.value = '';
  nameColorPicker.value = '#ffffff';
  tagColorPicker.value = '#ffd400';
  tagHex.value = '#ffd400';
  currentSelectedActivity = null;

  if(s && s.activity){
    const inRaid = RAID_DATA.find(r=>r.name===s.activity.name);
    const inDonjon = DONJON_DATA.find(d=>d.name===s.activity.name);
    if(inRaid) categorySelect.value = 'raid';
    else if(inDonjon) categorySelect.value = 'donjon';
    else categorySelect.value = 'custom';
    currentSelectedActivity = {...s.activity};
    nameColorPicker.value = s.activity.color || '#ffffff';
  }
  if(s && s.special){
    specialSelect.value = s.special.type || 'none';
    if(s.special.type === 'custom'){
      specialName.style.display='block';
      specialName.value = s.special.name || '';
    }
    specialRules.value = s.special.rules || '';
    tagColorPicker.value = s.special.color || '#ffd400';
    tagHex.value = s.special.color || '#ffd400';
  }

  // préparer sliders: si la case a des tailles sauvegardées => use them, sinon fallback aux variables CSS
  const defaultActivityFont = getDefaultActivityFont();
  const defaultTagFont = getDefaultTagFont();

  const savedActivityFont = s?.fontSizes?.activity ?? defaultActivityFont;
  const savedTagFont = s?.fontSizes?.tag ?? defaultTagFont;

  activityFontRange.value = savedActivityFont;
  activityFontValue.textContent = savedActivityFont + 'px';
  tagFontRange.value = savedTagFont;
  tagFontValue.textContent = savedTagFont + 'px';

  renderActivityList();
  highlightSelected();

  // preview: modify the clicked slot only (live preview)
  const [day,hour] = key.split('-');
  const slotSelector = `.slot[data-day="${day}"][data-hour="${hour}"]`;
  const slotEl = document.querySelector(slotSelector);
  if(slotEl){
    // save backup for cancel
    const nameEl = slotEl.querySelector('.activity-name');
    const tagEl = slotEl.querySelector('.tag');
    previewBackup[key] = {
      nameFont: nameEl ? (nameEl.style.fontSize || '') : '',
      tagFont: tagEl ? (tagEl.style.fontSize || '') : '',
      tagExists: !!tagEl
    };
    // apply preview sizes
    if(nameEl) nameEl.style.fontSize = savedActivityFont + 'px';
    if(tagEl) tagEl.style.fontSize = savedTagFont + 'px';
  }

  modalBack.style.display = 'flex';
}

/* click slots */
document.querySelectorAll('.slot').forEach(slot=>{
  slot.addEventListener('click', ()=>{
    const key = slot.dataset.day + '-' + slot.dataset.hour;
    openModalForKey(key);
  });
});

/* modal events */
categorySelect.addEventListener('change', ()=>{ currentSelectedActivity=null; renderActivityList(); });
specialSelect.addEventListener('change', (e)=>{
  const v = e.target.value;
  if(v === 'custom'){ specialName.style.display='block'; specialName.focus(); }
  else { specialName.style.display='none'; specialName.value=''; }
  if(v === 'roulette'){
    tagColorPicker.value = getComputedStyle(document.documentElement).getPropertyValue('--roulette-default').trim() || '#ffd400';
    tagHex.value = tagColorPicker.value;
    specialRules.value = DEFAULT_RULES.roulette;
  }
  if(v === 'special'){
    tagColorPicker.value = getComputedStyle(document.documentElement).getPropertyValue('--special-default').trim() || '#ff3b3b';
    tagHex.value = tagColorPicker.value;
    specialRules.value = DEFAULT_RULES.special;
  }
  if(v === 'none'){
    specialRules.value = '';
  }
});
tagColorPicker.addEventListener('input', ()=> tagHex.value = tagColorPicker.value);
tagHex.addEventListener('input', ()=>{
  const v = tagHex.value.trim();
  if(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)) tagColorPicker.value = v;
});

/* règles par défaut */
const DEFAULT_RULES = {
  roulette: "Chaque joueur aura droit à 3 tirage ce qui déterminera l'arme qu'il devra garder tout le long du raid. Les tirages ne sont pas rétroactifs alors choisissez bien.",
  special: "Composition d'une majorité de joueurs expérimentés, afin de prendre le temps pour l'apprentissage d'activités considérées difficiles."
};

/* slider live listeners (mise à jour du preview sur la case courante) */
function applyPreviewFontSizesToCurrentSlot(){
  if(!currentKey) return;
  const [day,hour] = currentKey.split('-');
  const slotSelector = `.slot[data-day="${day}"][data-hour="${hour}"]`;
  const slotEl = document.querySelector(slotSelector);
  if(!slotEl) return;
  const nameEl = slotEl.querySelector('.activity-name');
  const tagEl = slotEl.querySelector('.tag');

  const aSize = parseInt(activityFontRange.value);
  const tSize = parseInt(tagFontRange.value);

  if(nameEl) nameEl.style.fontSize = aSize + 'px';
  if(tagEl) tagEl.style.fontSize = tSize + 'px';

  activityFontValue.textContent = aSize + 'px';
  tagFontValue.textContent = tSize + 'px';
}

activityFontRange.addEventListener('input', applyPreviewFontSizesToCurrentSlot);
tagFontRange.addEventListener('input', applyPreviewFontSizesToCurrentSlot);

/* save */
saveBtn.addEventListener('click', ()=>{
  if(!currentKey) return;

  // activité principale
  let activity = null;
  if(categorySelect.value === 'custom'){
    if(currentSelectedActivity && currentSelectedActivity.custom){
      activity = {...currentSelectedActivity, color:nameColorPicker.value};
    }else{
      const name = prompt("Nom de l'activité personnalisée :","Activité") || "Activité";
      activity = { name, color:nameColorPicker.value };
    }
  }else{
    if(currentSelectedActivity){
      activity = {...currentSelectedActivity, color:nameColorPicker.value};
    }else{
      const list = categorySelect.value === 'raid' ? RAID_DATA : DONJON_DATA;
      const first = list[0];
      activity = { name:first.name, color:first.color };
    }
  }

  // activité spéciale
  const type = specialSelect.value;
  let special = null;
  if(type !== 'none'){
    const name = type === 'custom'
      ? (specialName.value.trim() || 'Personnalisée')
      : (type === 'roulette' ? 'Roulette' : 'Soirée spéciale');
    let rules = specialRules.value.trim();
    if (!rules) {
      if (type === 'roulette') rules = DEFAULT_RULES.roulette;
      else if (type === 'special') rules = DEFAULT_RULES.special;
      else rules = ""; 
    }
    const color = tagColorPicker.value || '#ffffff';
    special = { type, name, rules, color };
  }

  // font sizes (sauvegarde par case)
  const fontSizes = {
    activity: parseInt(activityFontRange.value),
    tag: parseInt(tagFontRange.value)
  };

  state[currentKey] = { activity, special, fontSizes };
  modalBack.style.display = 'none';
  currentKey = null;
  currentSelectedActivity = null;
  refreshGrid();
});

/* cancel */
cancelBtn.addEventListener('click', ()=>{
  // restore preview backup if exists
  if(currentKey && previewBackup[currentKey]){
    const [day,hour] = currentKey.split('-');
    const slotSelector = `.slot[data-day="${day}"][data-hour="${hour}"]`;
    const slotEl = document.querySelector(slotSelector);
    if(slotEl){
      const nameEl = slotEl.querySelector('.activity-name');
      const tagEl = slotEl.querySelector('.tag');
      const b = previewBackup[currentKey];
      if(nameEl) nameEl.style.fontSize = b.nameFont || '';
      if(tagEl) {
        tagEl.style.fontSize = b.tagFont || '';
      } else if(b.tagExists){
        // if tag previously existed but currently not in DOM, nothing to do
      }
    }
    delete previewBackup[currentKey];
  }

  modalBack.style.display='none';
  currentKey=null;
  currentSelectedActivity=null;
});

/* refresh grid */
function refreshGrid(){
  document.querySelectorAll('.slot').forEach(slot=>{
    const key = slot.dataset.day + '-' + slot.dataset.hour;
    const s = state[key];
    const nameEl = slot.querySelector('.activity-name');
    const content = slot.querySelector('.content');
    const existingTag = slot.querySelector('.tag');
    if(existingTag) existingTag.remove();

    const borderW = getComputedStyle(document.documentElement).getPropertyValue('--border-w').trim() || '3px';

    if(s && s.activity){
      slot.classList.remove('empty');
      nameEl.textContent = s.activity.name;
      nameEl.style.color = s.activity.color || '#ffffff';

      // apply font size if stored for this case, otherwise leave CSS variable default
      if(s.fontSizes && s.fontSizes.activity) nameEl.style.fontSize = s.fontSizes.activity + 'px';
      else nameEl.style.fontSize = ''; // reset to CSS var

      // bordure par défaut
      slot.style.border = `${borderW} solid rgba(255,255,255,0.4)`;

      if(s.special){
        const borderColor = s.special.color || '#ffffff';
        // bordure = couleur du tag
        slot.style.border = `${borderW} solid ${borderColor}`;

        // tag texte seul, Cinzel, couleur = borderColor
        const t = document.createElement('div');
        t.className = 'tag';
        t.textContent = s.special.name;
        t.style.color = borderColor;
        t.style.fontFamily = 'Cinzel, serif';
        t.style.background = 'transparent';

        // apply stored tag font size or default
        if(s.fontSizes && s.fontSizes.tag) t.style.fontSize = s.fontSizes.tag + 'px';

        content.appendChild(t);
      }
    }else{
      slot.classList.add('empty');
      nameEl.textContent = 'Vide';
      nameEl.style.color = '#ddd';
      nameEl.style.fontSize = ''; // reset
      slot.style.border = `${borderW} solid rgba(255,255,255,0.2)`;
    }
  });
  updateRules();
}

/* rules */
function updateRules(){
  const keys = Object.keys(state);

  const rouletteKey = keys.find(k => state[k]?.special?.type === 'roulette');
  const specialKey  = keys.find(k => state[k]?.special?.type === 'special');
  const customKey   = keys.find(k => state[k]?.special?.type === 'custom');

  const lines = [];

  if(rouletteKey){
    const s = state[rouletteKey].special;
    lines.push({
      title: 'Roulette',
      text: s.rules || DEFAULT_RULES.roulette,
      color: s.color || '#ffd400'
    });
  }

  if(specialKey){
    const s = state[specialKey].special;
    lines.push({
      title: 'Soirée spéciale',
      text: s.rules || DEFAULT_RULES.special,
      color: s.color || '#ff3b3b'
    });
  }

  if(customKey){
    const s = state[customKey].special;
    lines.push({
      title: s.name || 'Personnalisée',
      text: s.rules || '',
      color: s.color || '#ffffff'
    });
  }

  if(!lines.length){
    rulesArea.style.display='none';
    rulesContent.innerHTML='';
  }else{
    rulesArea.style.display='flex';
    rulesContent.innerHTML = lines.map(l =>
      `<div class="rule-line" style="color:${l.color}">
         <strong>${l.title} :</strong> ${l.text}
       </div>`
    ).join('');
  }
}

/* reset */
resetBtn.addEventListener('click', ()=>{
  if(!confirm('Réinitialiser toutes les cases ?')) return;
  state = {};
  refreshGrid();
});

/* export PNG
   - on retire temporairement la transformation visuelle du wrapper et du canvas pour capturer la source propre
   - finally garantit le nettoyage si html2canvas plante
*/
exportPng.addEventListener('click', async () => {
  try {
    // masquer UI (n'affecte pas la topbar hors du canvas)
    canvas.classList.add('capture');
    modalBack.style.display = 'none';

    // petit délai pour que le DOM applique la classe
    await new Promise(r => setTimeout(r, 120));

    // --- Créer une copie temporaire des dates DANS le canvas ---
    const tmpDates = document.createElement('div');
    tmpDates.className = 'export-dates-temp';
    // récupérer textes (format affiché)
    const startText = displayStart.textContent || '—';
    const endText = displayEnd.textContent || '—';
    tmpDates.innerHTML = `
      <div class="export-date export-start">${startText}</div>
      <div class="export-date export-end">${endText}</div>
    `;
    // style inline pour s'assurer qu'il est capturé correctement
    Object.assign(tmpDates.style, {
      position: 'absolute',
      left: 'var(--topbar-left)',   // place approximative alignée avec topbar
      top: 'calc(var(--topbar-top) + 6px)', // ajuster si besoin
      width: 'var(--grid-width)',
      display: 'flex',
      gap: '12px',
      justifyContent: 'flex-start',
      alignItems: 'center',
      pointerEvents: 'none',
      zIndex: 999
    });
    // styles pour les deux dates (tu peux ajuster taille/couleur)
    const css = document.createElement('style');
    css.textContent = `
      .export-dates-temp .export-date {
        font-family: "Cinzel", serif;
        font-weight: 700;
        color: #ffffff;
        font-size: var(--font-day);
        line-height: 1;
        margin-right: 18px;
        text-shadow: 0 1px 0 rgba(0,0,0,0.6);
      }
    `;
    // injecter dans le canvas (avant capture)
    canvas.appendChild(css);
    canvas.appendChild(tmpDates);

    // sauvegarder transform actuel et le retirer pour capture propre
    const prevWrapperTransform = canvasWrapper ? canvasWrapper.style.transform : '';
    const prevWrapperOrigin = canvasWrapper ? canvasWrapper.style.transformOrigin : '';
    const prevCanvasTransform = canvas.style.transform;
    const prevCanvasOrigin = canvas.style.transformOrigin;

    if (canvasWrapper) {
      canvasWrapper.style.transform = 'none';
      canvasWrapper.style.transformOrigin = 'top left';
    }
    canvas.style.transform = 'none';
    canvas.style.transformOrigin = 'top left';

    // capture à haute résolution
    const img = await html2canvas(canvas, { scale: 2, useCORS: true, backgroundColor: null });

    // restaurer transform
    if (canvasWrapper) {
      canvasWrapper.style.transform = prevWrapperTransform;
      canvasWrapper.style.transformOrigin = prevWrapperOrigin;
    }
    canvas.style.transform = prevCanvasTransform;
    canvas.style.transformOrigin = prevCanvasOrigin;

    // retirer l'élément temporaire et le style injecté
    tmpDates.remove();
    css.remove();

    // --- construire un nom de fichier sûr contenant les dates ---
    // on récupère les valeurs ISO des inputs si disponibles, sinon on utilise le texte affiché
    function safeDateForFilename(inputValue, displayText) {
      if (inputValue) {
        // inputValue est "YYYY-MM-DD" -> on convertit en "DD-MM-YYYY"
        const parts = inputValue.split('-');
        if (parts.length === 3) return `${parts[2]}-${parts[1]}-${parts[0]}`;
      }
      // fallback : tenter d'extraire jour/mois/année depuis le texte affiché
      // ex: "12 janv." -> on retourne tel quel en remplaçant espaces par _
      return displayText.replace(/\s+/g, '_').replace(/[\/\\:]/g, '-');
    }
    const startSafe = safeDateForFilename(inputStart.value, displayStart.textContent);
    const endSafe = safeDateForFilename(inputEnd.value, displayEnd.textContent);
    const filename = `planning-${startSafe}_${endSafe}.png`;

    // télécharger
    const a = document.createElement('a');
    a.href = img.toDataURL('image/png');
    a.download = filename;
    a.click();

  } catch (err) {
    alert('Erreur PNG : ' + (err && err.message ? err.message : err));
  } finally {
    // s'assurer que la classe est toujours retirée
    canvas.classList.remove('capture');
    modalBack.style.display = 'none';
  }
});


/* date pickers: ouvrir input[type=date] via bouton et mettre à jour l'affichage */
displayStart.addEventListener('click', ()=> {
  inputStart.focus();
  inputStart.click();
});
displayEnd.addEventListener('click', ()=> {
  inputEnd.focus();
  inputEnd.click();
});
inputStart.addEventListener('change', (e)=>{
  displayStart.textContent = formatShortDate(e.target.value);
});
inputEnd.addEventListener('change', (e)=>{
  displayEnd.textContent = formatShortDate(e.target.value);
});

/* init */
(function init(){
  applyLayout();
  renderActivityList();
  refreshGrid();
  function applyScale(){
    const canvasW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--canvas-w')) || 1536;
    const canvasH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--canvas-h')) || 1024;

    const scaleX = (window.innerWidth - 40) / canvasW;
    const scaleY = (window.innerHeight - 40) / canvasH;

    const scale = Math.min(scaleX, scaleY, 1);

    // on scale le wrapper (pas le canvas directement) pour que la topbar (hors du canvas) ne soit pas affectée
    if (canvasWrapper) {
      canvasWrapper.style.transform = 'scale(' + scale + ')';
      canvasWrapper.style.transformOrigin = 'top left';
    } else {
      // fallback si wrapper manquant
      canvas.style.transform = 'scale(' + scale + ')';
      canvas.style.transformOrigin = 'top left';
    }
  }
  applyScale();
  window.addEventListener('resize', applyScale);

  // initialiser sliders par défaut (valeurs depuis CSS vars)
  activityFontRange.value = getDefaultActivityFont();
  activityFontValue.textContent = activityFontRange.value + 'px';
  tagFontRange.value = getDefaultTagFont();
  tagFontValue.textContent = tagFontRange.value + 'px';
})();

/* API utilitaire : changer layout depuis la console
   Exemple:
     setLayout({ topbar:{left:100,top:20}, grid:{left:10,top:150}, offsets:{ displayStart:{x:10,y:0} } })
*/
window.setLayout = function(newLayout){
  Object.assign(layout, newLayout);
  applyLayoutFromObject(layout);
  // keep inline positions for legacy code
  if (newLayout.topbar) {
    topbar.style.left = (newLayout.topbar.left ?? layout.topbar.left) + 'px';
    topbar.style.top = (newLayout.topbar.top ?? layout.topbar.top) + 'px';
  }
  if (newLayout.grid) {
    gridWrap.style.left = (newLayout.grid.left ?? layout.grid.left) + 'px';
    gridWrap.style.top = (newLayout.grid.top ?? layout.grid.top) + 'px';
  }
  if (newLayout.rules) {
    rulesArea.style.left = (newLayout.rules.left ?? layout.rules.left) + 'px';
    rulesArea.style.top = (newLayout.rules.top ?? layout.rules.top) + 'px';
  }
};
</script>
</body>
</html>
